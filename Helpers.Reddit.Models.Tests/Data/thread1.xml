<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/"><category term="docker" label="r/docker"/><updated>2020-09-27T01:56:51+00:00</updated><icon>https://www.redditstatic.com/icon.png/</icon><id>/r/docker/comments/izobdi/trapping_hackers_with_containerized_deception/.rss</id><link rel="self" href="https://old.reddit.com/r/docker/comments/izobdi/trapping_hackers_with_containerized_deception/.rss" type="application/atom+xml" /><link rel="alternate" href="https://old.reddit.com/r/docker/comments/izobdi/trapping_hackers_with_containerized_deception/" type="text/html" /><subtitle>[Docker](http://www.docker.io) is an open-source project to easily create lightweight, portable, self-sufficient containers from any application. The same container that a developer builds and tests on a laptop can run at scale, in production, on VMs, bare metal, OpenStack clusters, public clouds and more.</subtitle><title>Trapping Hackers with Containerized Deception : docker</title><entry><author><name>/u/GuessRemarkable</name><uri>https://old.reddit.com/user/GuessRemarkable</uri></author><category term="docker" label="r/docker"/><content type="html">&lt;!-- SC_OFF --&gt;&lt;div class=&quot;md&quot;&gt;&lt;h1&gt;TL;DR&lt;/h1&gt; &lt;p&gt;This article explores modern honeypots that leverage containerization by walking through the design of a high-interaction honeypot that can use arbitrary Docker containers to lure malicious attacks.&lt;/p&gt; &lt;h1&gt;Introduction&lt;/h1&gt; &lt;p&gt;While honeypots have been around for a very long time, this article will attempt to provide a fresh look at how containerization has affected the way we use honeypots in containerized environments today. Admittedly, I haven&amp;#39;t explored this topic since 2005. So, while researching for something to implement that would be equally valuable and interesting, I ran into at least half a dozen false starts. I assumed that, like every other area of computing, advanced honeypot systems would abound in the open-source community. But, I suppose I underestimated both the esoteric nature of the subject, as well as its well guarded commercial viability.&lt;/p&gt; &lt;p&gt;A lot has changed since 2005, but a lot has remained the same. A honeypot is not a complicated concept; it&amp;#39;s a system or service that intentionally exposes itself to attackers so that they can be detected as somebody tries to break in. Different than an intrusion detection system, a honeypot can be something as simple as a few lines of code that disguises itself to be a vulnerable open port on a system, or it can be something as advanced as a full-blown operating system with a secret logging system that analyzes patterns of behavior.&lt;/p&gt; &lt;p&gt;However, as developers and systems experts incorporate containerization into their designs, many of the traditional approaches to using honeypots become far less effective. In 2005, deploying a honeypot was often done once, usually placed somewhere easily accessible to the rest of the network. But with containerized systems, because of their isolation from networks and other services, deploying a honeypot, in the same way, becomes useless.&lt;/p&gt; &lt;p&gt;While developers are technically savvy, it is often the case that they aren&amp;#39;t security literate. Even if they are, it&amp;#39;s common to prioritize convenience. This makes securing Docker an even more critical part of a security minded DevOps professional. The same could be said for overburdened systems administrators that take a deemphasized approach to security in an effort to get the job done quickly.&lt;/p&gt; &lt;p&gt;Much of the problem stems from the fact that developers often have a very high level of access to computing resources within the company. Systems administrators, by necessity, have an even higher level of access than developers. Not only do they have access to all the source code in the system, along with the ability to test databases, but in many cases, especially in DevOps environments, they may even have access to production systems. In addition, developers need to perform many tasks for testing purposes that look suspicious to security software, providing cause to disable security software. This gives malicious software and attackers an even easier target to infect system hardware.&lt;/p&gt; &lt;p&gt;In the case of running Docker on a local windows environment, as many developers do for development purposes, it can&amp;#39;t be trusted that all development systems will adhere to proper security configurations. In my case, I have often enabled the Docker remote API on a host for testing purposes and left it enabled, either out of forgetfulness or because of convenience.&lt;/p&gt; &lt;h1&gt;Overview of Deception Systems&lt;/h1&gt; &lt;h2&gt;Honeypots&lt;/h2&gt; &lt;p&gt;Honeypots can be deployed alongside different types of systems in your network. They are decoys designed to lure attackers and malicious software so that the source can be detected, logged, and tracked. There are various types of honeypot. High interaction honey pots are designed to run as a service and is meant to be complex enough to fool a system into believing it is a full-featured operating system or device. Mid interaction honeypots emulate certain aspects of an application layer without being too complex and therefore making it more difficult to be easily compromised. Low interaction honeypots, which is what we will be discussing in this article, are easy to deploy and maintain, while serving as a simple early warning system to prevent infection of more critical systems in the environment.&lt;/p&gt; &lt;h2&gt;Honeynets&lt;/h2&gt; &lt;p&gt;A honeynet is a collection of honeypots designed to strategically track the methods and techniques of malicious software and attackers. This approach allows administrators to watch hackers and malicious code exploit the various vulnerabilities of the system, and can be used either in production or for research purposes to discover new vulnerabilities and attacks.&lt;/p&gt; &lt;h2&gt;Basic Use Case&lt;/h2&gt; &lt;p&gt;Honeypots have the advantage of not requiring detailed knowledge about network attack methodology. This is especially true of low interaction honeypots, which are relatively simple applications which sit on a port and listen, often imitating very little of the original service. They log access attempts and do little else. Such data collection can be invaluable when collecting certain types of access information, or to serve as an early warning of a compromised service, before there are any serious problems.&lt;/p&gt; &lt;h2&gt;Background&lt;/h2&gt; &lt;h2&gt;Vulnerabilities&lt;/h2&gt; &lt;p&gt;Using containers as honeypots have been the source of some debate, as containerization technology is both comparably immature compared to full virtualization. It can also be easy for some administrators to overlook potential configuration issues, such as the ones that follow.&lt;/p&gt; &lt;h2&gt;Docker Engine API&lt;/h2&gt; &lt;p&gt;An API is a programming interface for applications. It is a type of protocol; a ruleset; sometimes with abstraction, but regardless of implementation, it is always a standard method for programs of different types to talk to one another. REST stands for &amp;quot;Representational State Transfer&amp;quot;. It is a standard which developers can use in order to get and exchange information with other applications, sending a request for information in the form of a specific URL, while receiving data in the body of the return response.&lt;/p&gt; &lt;p&gt;The Docker Engine API is used by the Docker CLI to manage objects. Although a UNIX socket (unix:///var/run/docker.sock)is enabled by default on Linux systems, a TCP socket (tcp://127.0.0.1:2376) is enabled by default on Windows systems. On Linux systems, for development and automation purposes, this API can also be accessed directly by remote applications as a REST API by enabling it to be used by a TCP socket.&lt;/p&gt; &lt;h2&gt;Base Images&lt;/h2&gt; &lt;p&gt;Most of the vulnerabilities found today are in the base images themselves. In the case of Docker, the base image is composed of an operating system, often customized from another popular image found on Docker Hub. Customizations, malicious or accidental, along with the original base image, creates plenty of opportunities for attacks, sometimes even by the most novice of hackers.&lt;/p&gt; &lt;h2&gt;Docker Hub&lt;/h2&gt; &lt;p&gt;While Docker Hub has removed malicious Docker containers in the past, as a community repository, it is wide open to abuse and attack. Base images uploaded to Docker Hub should be used with caution. But given that many administrators decide that the convenience often outweighs the risk, taking prudent security measures to mitigate the risk of attack would be warranted.&lt;/p&gt; &lt;h2&gt;Notable Honeypot Systems&lt;/h2&gt; &lt;p&gt;There are a number of honeypot systems in popular use, however, very few specifically target or uniquely benefit the use of containerization. The two following open source packages are notable exceptions.&lt;/p&gt; &lt;h1&gt;Modern Honey Network&lt;/h1&gt; &lt;p&gt;&lt;a href=&quot;https://github.com/pwnlandia/mhn&quot;&gt;MHN&lt;/a&gt; has a lot of potential for container integration, yet it is not officially supported to run Docker. As a comprehensive honeynet management system, honeypots could be easily deployed as part of a K8s configuration with a little effort. The honeypot data collected from internal network sources, in particular, could be invaluable to securing a distributed container environment.&lt;/p&gt; &lt;h2&gt;Oncyberblog&amp;#39;s Whaler: A Docker API Honeypot&lt;/h2&gt; &lt;p&gt;&amp;#x200B;&lt;/p&gt; &lt;p&gt;Over a dozen GitHub repositories bare the name Whaler, yet &lt;a href=&quot;https://github.com/oncyberblog/whaler&quot;&gt;this&lt;/a&gt; one by &lt;a href=&quot;https://github.com/oncyberblog&quot;&gt;Oncyberblog&lt;/a&gt; was actually a projected contender for this article. This project is unique because it attempts to lure attackers using an exposed Docker Engine API. It does have its limitations, however. First, because it is running an embedded Docker container, Docker must be run in privileged mode on its host. This is a problem because its an enormous security risk that could jeopardize the security of the host. Therefore, it would be necessary to take precautions by installing it on an isolated and secured host. The system requirements aren&amp;#39;t demanding, so the host doesn&amp;#39;t need to be of any substantial size. However, since you would need to monitor individual containers on the primary host, you would need a method of linking the segregated honeypot host to the application host in which the monitored application containers would be located.&lt;/p&gt; &lt;h2&gt;System Overview&lt;/h2&gt; &lt;p&gt;This project makes quick use of old-school Linux internals to handle container orchestration, load balancing, and security. For more information, source code, and updates, see &lt;a href=&quot;https://github.com/mrhavens/DockerTrap&quot;&gt;DockerTrap&lt;/a&gt;, the companion GitHub repository created for this article.&lt;/p&gt; &lt;h2&gt;System configuration&lt;/h2&gt; &lt;h2&gt;Change default port of SSH on the host&lt;/h2&gt; &lt;p&gt;Before doing anything else, change the default port from &lt;code&gt;22&lt;/code&gt; to something else, like &lt;code&gt;2222&lt;/code&gt;. The system will be luring attackers using port &lt;code&gt;22&lt;/code&gt;, so this port should be freed of use.&lt;/p&gt; &lt;h2&gt;Install Docker&lt;/h2&gt; &lt;pre&gt;&lt;code&gt;sudo apt -y install apt-transport-https ca-certificates curl software-properties-common curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository &amp;quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&amp;quot; sudo apt update apt-cache policy docker-ce sudo apt -y install docker-ce &lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Install supporting system tools&lt;/h2&gt; &lt;pre&gt;&lt;code&gt;sudo apt update sudo apt -y install socat xinetd auditd netcat-openbsd &lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Configure xinetd&lt;/h2&gt; &lt;p&gt;This system makes use of the following bash script, managed by &lt;code&gt;xinetd&lt;/code&gt;, to spin up containers whenever an incoming connection is requested by port &lt;code&gt;22&lt;/code&gt;.The following &lt;code&gt;bash&lt;/code&gt; script should be made available to &lt;code&gt;xinetd&lt;/code&gt; as &lt;code&gt;/usr/bin/honeypot&lt;/code&gt; with &lt;code&gt;755&lt;/code&gt; permissions and root ownership.&lt;/p&gt; &lt;p&gt;The &lt;code&gt;EXT_IFACE&lt;/code&gt; variable should be changed to the interface that corresponds with the device you wish to receive incoming ssh connections on port &lt;code&gt;22&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;#!/bin/bash EXT_IFACE=ens4 MEM_LIMIT=128M SERVICE=22 QUOTA_IN=5242880 QUOTA_OUT=1310720 REMOTE_HOST=`echo ${REMOTE_HOST} | grep -o &amp;#39;[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}&amp;#39;` { CONTAINER_NAME=&amp;quot;honeypot-${REMOTE_HOST}&amp;quot; HOSTNAME=$(/bin/hostname) # check if the container exists if ! /usr/bin/docker inspect &amp;quot;${CONTAINER_NAME}&amp;quot; &amp;amp;&amp;gt; /dev/null; then # create new container CONTAINER_ID=$(/usr/bin/docker run --name ${CONTAINER_NAME} -h ${HOSTNAME} -e &amp;quot;REMOTE_HOST=${REMOTE_HOST}&amp;quot; -m ${MEM_LIMIT} -d -i honeypot ) ##/sbin/init) CONTAINER_IP=$(/usr/bin/docker inspect --format &amp;#39;{{ .NetworkSettings.IPAddress }}&amp;#39; ${CONTAINER_ID}) PROCESS_ID=$(/usr/bin/docker inspect --format &amp;#39;{{ .State.Pid }}&amp;#39; ${CONTAINER_ID}) # drop all inbound and outbound traffic by default /usr/bin/nsenter --target ${PROCESS_ID} -n /sbin/iptables -P INPUT DROP /usr/bin/nsenter --target ${PROCESS_ID} -n /sbin/iptables -P OUTPUT DROP # allow access to the service regardless of the quota /usr/bin/nsenter --target ${PROCESS_ID} -n /sbin/iptables -A INPUT -p tcp -m tcp --dport ${SERVICE} -j ACCEPT /usr/bin/nsenter --target ${PROCESS_ID} -n /sbin/iptables -A INPUT -m quota --quota ${QUOTA_IN} -j ACCEPT # allow related outbound access limited by the quota /usr/bin/nsenter --target ${PROCESS_ID} -n /sbin/iptables -A OUTPUT -p tcp --sport ${SERVICE} -m state --state ESTABLISHED,RELATED -m quota --quota ${QUOTA_OUT} -j ACCEPT # enable the host to connect to rsyslog on the host /usr/bin/nsenter --target ${PROCESS_ID} -n /sbin/iptables -A OUTPUT -p tcp -m tcp --dst 172.17.0.1 --dport 514 -j ACCEPT # add iptables redirection rule /sbin/iptables -t nat -A PREROUTING -i ${EXT_IFACE} -s ${REMOTE_HOST} -p tcp -m tcp --dport ${SERVICE} -j DNAT --to-destination ${CONTAINER_IP} /sbin/iptables -t nat -A POSTROUTING -j MASQUERADE else # start container if exited and grab the cid /usr/bin/docker start &amp;quot;${CONTAINER_NAME}&amp;quot; &amp;amp;&amp;gt; /dev/null CONTAINER_ID=$(/usr/bin/docker inspect --format &amp;#39;{{ .Id }}&amp;#39; &amp;quot;${CONTAINER_NAME}&amp;quot;) CONTAINER_IP=$(/usr/bin/docker inspect --format &amp;#39;{{ .NetworkSettings.IPAddress }}&amp;#39; ${CONTAINER_ID}) # add iptables redirection rule /sbin/iptables -t nat -A PREROUTING -i ${EXT_IFACE} -s ${REMOTE_HOST} -p tcp -m tcp --dport ${SERVICE} -j DNAT --to-destination ${CONTAINER_IP} /sbin/iptables -t nat -A POSTROUTING -j MASQUERADE fi echo ${CONTAINER_IP} } &amp;amp;&amp;gt; /dev/null # forward traffic to the container exec /usr/bin/socat stdin tcp:${CONTAINER_IP}:22,retry=60 &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The following service file should be created as &lt;code&gt;/etc/xinetd.d/honeypot&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;# Container launcher for an SSH honeypot service honeypot { disable = no instances = UNLIMITED server = /usr/bin/honeypot socket_type = stream protocol = tcp port = 22 user = root wait = no log_type = SYSLOG authpriv info log_on_success = HOST PID log_on_failure = HOST } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Then, &lt;code&gt;/etc/services&lt;/code&gt; should be updated to include the following to reflect the new ssh port and the honeypot port at port &lt;code&gt;22&lt;/code&gt;&lt;/p&gt; &lt;pre&gt;&lt;code&gt;ssh 2222/tcp honeypot 22/tcp &lt;/code&gt;&lt;/pre&gt; &lt;h1&gt;Configure crond&lt;/h1&gt; &lt;p&gt;To handle stopping and cleaning up old containers, the following bash script should be deployed to &lt;code&gt;/usr/bin/honeypot.clean&lt;/code&gt; with &lt;code&gt;755&lt;/code&gt; permissions and root ownership.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;#!/bin/bash EXT_IFACE=ens4 SERVICE=22 HOSTNAME=$(/bin/hostname) LIFETIME=$((3600 * 6)) # Six hours datediff () { d1=$(/bin/date -d &amp;quot;$1&amp;quot; +%s) d2=$(/bin/date -d &amp;quot;$2&amp;quot; +%s) echo $((d1 - d2)) } for CONTAINER_ID in $(/usr/bin/docker ps -a --no-trunc | grep &amp;quot;honeypot-&amp;quot; | cut -f1 -d&amp;quot; &amp;quot;); do STARTED=$(/usr/bin/docker inspect --format &amp;#39;{{ .State.StartedAt }}&amp;#39; ${CONTAINER_ID}) RUNTIME=$(datediff now &amp;quot;${STARTED}&amp;quot;) if [[ &amp;quot;${RUNTIME}&amp;quot; -gt &amp;quot;${LIFETIME}&amp;quot; ]]; then logger -p local3.info &amp;quot;Stopping honeypot container ${CONTAINER_ID}&amp;quot; /usr/bin/docker stop $CONTAINER_ID fi RUNNING=$(/usr/bin/docker inspect --format &amp;#39;{{ .State.Running }}&amp;#39; ${CONTAINER_ID}) if [[ &amp;quot;$RUNNING&amp;quot; != &amp;quot;true&amp;quot; ]]; then # delete iptables rule CONTAINER_IP=$(/usr/bin/docker inspect --format &amp;#39;{{ .NetworkSettings.IPAddress }}&amp;#39; ${CONTAINER_ID}) REMOTE_HOST=$(/usr/bin/docker inspect --format &amp;#39;{{ .Name }}&amp;#39; ${CONTAINER_ID} | cut -f2 -d-) /sbin/iptables -t nat -D PREROUTING -i ${EXT_IFACE} -s ${REMOTE_HOST} -p tcp --dport ${SERVICE} -j DNAT --to-destination ${CONTAINER_IP} logger -p local3.info &amp;quot;Removing honeypot container ${CONTAINER_ID}&amp;quot; /usr/bin/docker rm $CONTAINER_ID fi done &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;By default, the above script is set to run every 5 minutes by appending the following to &lt;code&gt;/etc/crontab&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;*/5 * * * * /usr/bin/honeypot.clean &lt;/code&gt;&lt;/pre&gt; &lt;h1&gt;Configure auditd&lt;/h1&gt; &lt;p&gt;Enable logging the execve systemcall in auditd by adding the following audit rules:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;auditctl -a exit,always -F arch=b64 -S execve auditctl -a exit,always -F arch=b32 -S execve &lt;/code&gt;&lt;/pre&gt; &lt;h1&gt;Deploy apitrap.sh&lt;/h1&gt; &lt;p&gt;The &lt;code&gt;apitrap.sh&lt;/code&gt; script is an optional component that makes an attempt to simulate a Docker API on the host. Since this is a bash script, it is recommended that it is run from a Docker container, run as an unprivileged user, and redirected to port 2375 or 2376 in order to avoid potential exploits.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;#!/bin/bash ## Docker API heading H1=&amp;quot;HTTP/1.1 404 Not Found\n&amp;quot; H2=&amp;quot;Content-Type: application/json\n&amp;quot; H3=&amp;quot;Date: &amp;quot;`date &amp;#39;+%a, %d %b %Y %T %Z&amp;#39;`&amp;quot;\n&amp;quot; H4=&amp;quot;Content-Length: 29\n\n&amp;quot; ## API error message B1=&amp;quot;{\&amp;quot;message\&amp;quot;:\&amp;quot;page not found\&amp;quot;}\n&amp;quot; HEADERS+=$H1$H2$H3$H4 ## Default to port 2376 if no port is given if ! test -z &amp;quot;$1&amp;quot;; then PORT=$1; else PORT=2376; fi QUEUE_FILE=/tmp/apitrap test -p $QUEUE_FILE &amp;amp;&amp;amp; rm $QUEUE_FILE mkfifo $QUEUE_FILE while true; do cat &amp;quot;$QUEUE_FILE&amp;quot; | nc -l &amp;quot;$PORT&amp;quot; | while read -r line || [[ -n &amp;quot;$line&amp;quot; ]]; do if echo $line | grep -q &amp;#39;GET \|HEAD \|POST \|PUT \|DELETE \|CONNECT \|OPTIONS \|TRACE&amp;#39;; then echo &amp;quot;&amp;gt;&amp;gt;&amp;gt; [&amp;quot;$(date)&amp;quot;] &amp;lt;&amp;lt;&amp;lt;&amp;quot; echo : $line echo -e $HEADERS$B1 &amp;gt; $QUEUE_FILE fi done done &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You would need to make appropriate changes to the system, but from inside any honeypot you decide to deploy, it should be possible to attain the host IP from inside a docker container. For example:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;root@dockerhost:~# hostname -I |awk &amp;#39;{ print $2 }&amp;#39; 172.17.0.1 root@dockerhost:~# docker run -it honeypot-test /sbin/ip route|awk &amp;#39;/default/ { print $3 }&amp;#39; 172.17.0.1 root@dockerhost:~# &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;We show that the hostname for dockerhost is &lt;code&gt;172.17.0.1&lt;/code&gt;. Retrieving the Docker container&amp;#39;s gateway address reveals that it is also &lt;code&gt;172.17.0.1&lt;/code&gt;. This quite easily makes the host IP available for attack from the container. We should therefore, exploit this for our project by making sure the configuration for DockerTrap is redirected and available on the same host. However, those details will not be discussed here. Look for updates on the &lt;a href=&quot;https://github.com/mrhavens/DockerTrap&quot;&gt;DockerTrap&lt;/a&gt; GitHub repository. &lt;/p&gt; &lt;h1&gt;Build honeypot image from Dockerfile&lt;/h1&gt; &lt;p&gt;The main feature of this image is that sshd is enabled, root login is enabled, and the password for root is set to &lt;code&gt;root&lt;/code&gt;. You should modify this to include other user accounts, along with trivial passwords that will help lure more attacks.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;FROM alpine:3.9 ENTRYPOINT [&amp;quot;/entrypoint.sh&amp;quot;] EXPOSE 22 ## Root is gloriously unsecure! RUN apk add --no-cache openssh \ &amp;amp;&amp;amp; sed -i s/#PermitRootLogin.*/PermitRootLogin\ yes/ /etc/ssh/sshd_config \ &amp;amp;&amp;amp; echo &amp;quot;root:root&amp;quot; | chpasswd RUN echo -e &amp;#39;#!/bin/ash\n\nssh-keygen -A\n/usr/sbin/sshd -D -e &amp;quot;$@&amp;quot;&amp;#39; &amp;gt; /entrypoint.sh RUN chmod 555 /entrypoint.sh &lt;/code&gt;&lt;/pre&gt; &lt;h1&gt;Commit final honeypot image&lt;/h1&gt; &lt;p&gt;The system looks for a base image committed as &lt;code&gt;honeypot:latest&lt;/code&gt;. As an ssh connection is made, the system automatically creates a unique instance of this image with the &lt;code&gt;honeypot&lt;/code&gt;- prefix. Modify this image as needed.&lt;/p&gt; &lt;h1&gt;Testing&lt;/h1&gt; &lt;h1&gt;SSH into honeypot&lt;/h1&gt; &lt;p&gt;Each of the dynamically created honeypots will adopt the hostname of the host. At this point, if any socket connection is established on port &lt;code&gt;22&lt;/code&gt; of localhost (or any other network adapter on the host that is configured to be used by DockerTrap), it will be redirected to the sshd daemon of the honeypot inside one of the honeypot containers. The Bash script, &lt;code&gt;/usr/bin/honeypot&lt;/code&gt; triggered by &lt;code&gt;xinetd&lt;/code&gt; makes sure that each IP address is directed to their corresponding container, so if an attacker attempts to log in from the same IP address a second, third, or fourth time, they will log into the same container each time.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;dockertrap:~# ssh root@localhost -p 22 The authenticity of host &amp;#39;localhost (127.0.0.1)&amp;#39; can&amp;#39;t be established. ECDSA key fingerprint is SHA256:dY6EIpV1nBw5143TkgPQU5SRWIkrxkZCiLWd+ktiNKE. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added &amp;#39;localhost&amp;#39; (ECDSA) to the list of known hosts. root@localhost&amp;#39;s password: Welcome to Alpine! The Alpine Wiki contains a large amount of how-to guides and general information about administrating Alpine systems. See &amp;lt;http://wiki.alpinelinux.org/&amp;gt;. You can setup the system with the command: setup-alpine You may change this message by editing /etc/motd. dockertrap:~# ifconfig -a eth0 Link encap:Ethernet HWaddr 02:42:AC:11:00:02 inet addr:172.17.0.2 Bcast:172.17.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:124 errors:0 dropped:0 overruns:0 frame:0 TX packets:96 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:13954 (13.6 KiB) TX bytes:14026 (13.6 KiB) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) dockertrap:~# exit Connection to localhost closed. root@dockertrap:~# &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Note that the ethernet device &lt;code&gt;eth0&lt;/code&gt; above is configured with an IP address of &lt;code&gt;172.17.0.2&lt;/code&gt; and a MAC address of &lt;code&gt;02:42:AC:11:00:02&lt;/code&gt;. When logging in from an IP address other than the host&amp;#39;s localhost, such as my home PC, DockerTrap will spawn a new, yet nearly identical container for me to log into (except for the IP and MAC address, of course).&lt;/p&gt; &lt;pre&gt;&lt;code&gt;C:\Users\user&amp;gt;ssh root@35.238.100.5 -p 22 The authenticity of host &amp;#39;35.238.100.5 (35.238.100.5)&amp;#39; can&amp;#39;t be established. ECDSA key fingerprint is SHA256:VKG+5VhB0WL5ncPomfmb+XW484LtjS8oAs+BDM07sJQ. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added &amp;#39;35.238.100.5&amp;#39; (ECDSA) to the list of known hosts. root@35.238.100.5&amp;#39;s password: Welcome to Alpine! The Alpine Wiki contains a large amount of how-to guides and general information about administrating Alpine systems. See &amp;lt;http://wiki.alpinelinux.org/&amp;gt;. You can setup the system with the command: setup-alpine You may change this message by editing /etc/motd. honeypot2:~# ifconfig -a eth0 Link encap:Ethernet HWaddr 02:42:AC:11:00:09 inet addr:172.17.0.9 Bcast:172.17.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:72 errors:0 dropped:0 overruns:0 frame:0 TX packets:50 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:7593 (7.4 KiB) TX bytes:7041 (6.8 KiB) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) honeypot2:~# exit Connection to 35.238.100.5 closed. C:\Users\user&amp;gt; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The IP address and MAC address are different, yet the hostname is the same. After a while, we will notice that an increasing number of containers begin to spin up on the host, as random bots connect to port &lt;code&gt;22&lt;/code&gt;. It is worth noting that in order to prevent a memory resource attack, you will want to edit the &lt;code&gt;/etc/xinetd.d/honeypot&lt;/code&gt; file so that &lt;code&gt;xinetd&lt;/code&gt; limits the number of instances.&lt;/p&gt; &lt;pre&gt;&lt;code&gt;root@dockertrap:/usr/bin# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4971d1c8272a honeypot &amp;quot;/entrypoint.sh&amp;quot; 17 minutes ago Up 17 minutes 22/tcp honeypot-175.111.182.186 bf4f9b94ad03 honeypot &amp;quot;/entrypoint.sh&amp;quot; 27 minutes ago Up 27 minutes 22/tcp honeypot-58.96.198.15 e69231243915 honeypot &amp;quot;/entrypoint.sh&amp;quot; 29 minutes ago Up 29 minutes 22/tcp honeypot- 906c4e2be5c7 honeypot &amp;quot;/entrypoint.sh&amp;quot; 30 minutes ago Up 30 minutes 22/tcp honeypot-10.128.0.46 root@dockertrap:/usr/bin# &lt;/code&gt;&lt;/pre&gt; &lt;h1&gt;Future Work&lt;/h1&gt; &lt;p&gt;Much of the design of DockerTrap can be applied to Kubernetes. Similar to how Docker enables resource restrictions here, K8s supports advanced &lt;a href=&quot;https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/&quot;&gt;security features&lt;/a&gt;, including an IPtables counterpart &lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/network-policies/&quot;&gt;network policy&lt;/a&gt;. The API honeypot &lt;code&gt;apitrap.sh&lt;/code&gt; can also be replaced by a more robust system like &lt;a href=&quot;https://github.com/oncyberblog/whaler&quot;&gt;Whaler&lt;/a&gt;, which would help identify compromised systems that specifically seek out misconfigured Docker hosts. &lt;/p&gt; &lt;p&gt;&lt;em&gt;This article was originally published on&lt;/em&gt; &lt;a href=&quot;https://appfleet.com/blog/compromised-container-detection-with-honeypot-containers/&quot;&gt;&lt;em&gt;https://appfleet.com/blog/compromised-container-detection-with-honeypot-containers/&lt;/em&gt;&lt;/a&gt; &lt;em&gt;and has been authorized by Appfleet for a republish.&lt;/em&gt;&lt;/p&gt; &lt;/div&gt;&lt;!-- SC_ON --&gt; &amp;#32; submitted by &amp;#32; &lt;a href=&quot;https://old.reddit.com/user/GuessRemarkable&quot;&gt; /u/GuessRemarkable &lt;/a&gt; &lt;br/&gt; &lt;span&gt;&lt;a href=&quot;https://old.reddit.com/r/docker/comments/izobdi/trapping_hackers_with_containerized_deception/&quot;&gt;[link]&lt;/a&gt;&lt;/span&gt; &amp;#32; &lt;span&gt;&lt;a href=&quot;https://old.reddit.com/r/docker/comments/izobdi/trapping_hackers_with_containerized_deception/&quot;&gt;[comments]&lt;/a&gt;&lt;/span&gt;</content><id>t3_izobdi</id><link href="https://old.reddit.com/r/docker/comments/izobdi/trapping_hackers_with_containerized_deception/" /><updated>2020-09-25T17:53:49+00:00</updated><title>Trapping Hackers with Containerized Deception</title></entry><entry><author><name>/u/mister2d</name><uri>https://old.reddit.com/user/mister2d</uri></author><category term="docker" label="r/docker" /><content type="html">&lt;!-- SC_OFF --&gt;&lt;div class=&quot;md&quot;&gt;&lt;p&gt;For something like this I would definitely run in a rootless container runtime. Too risky to run as it is (I looked over the git source).&lt;/p&gt; &lt;p&gt;I would also drop privileges in the Dockerfile to a non root user and reconfigure the sshd listening port to something &amp;gt;1024 for good measure.&lt;/p&gt; &lt;p&gt;Finally, I would create an interface just for this work (possibly a vlan interface). Or if you can&amp;#39;t add an interface, craft an iptables/firewalld rule to redirect port 22/tcp to the exposed port of the running container.&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/security/rootless&quot;&gt;https://docs.docker.com/engine/security/rootless&lt;/a&gt;&lt;/p&gt; &lt;/div&gt;&lt;!-- SC_ON --&gt;</content><id>t1_g6mkw2l</id><link href="https://old.reddit.com/r/docker/comments/izobdi/trapping_hackers_with_containerized_deception/g6mkw2l/"/><updated>2020-09-26T05:58:19+00:00</updated><title>/u/mister2d on Trapping Hackers with Containerized Deception</title></entry><entry><author><name>/u/chamunks</name><uri>https://old.reddit.com/user/chamunks</uri></author><category term="docker" label="r/docker" /><content type="html">&lt;!-- SC_OFF --&gt;&lt;div class=&quot;md&quot;&gt;&lt;p&gt;Well honey pots are supposed to look valuable.&lt;/p&gt; &lt;/div&gt;&lt;!-- SC_ON --&gt;</content><id>t1_g6ov6hv</id><link href="https://old.reddit.com/r/docker/comments/izobdi/trapping_hackers_with_containerized_deception/g6ov6hv/"/><updated>2020-09-26T15:14:00+00:00</updated><title>/u/chamunks on Trapping Hackers with Containerized Deception</title></entry><entry><author><name>/u/mister2d</name><uri>https://old.reddit.com/user/mister2d</uri></author><category term="docker" label="r/docker" /><content type="html">&lt;!-- SC_OFF --&gt;&lt;div class=&quot;md&quot;&gt;&lt;p&gt;True statement. However, you&amp;#39;ll want to protect the host from a container breakout.&lt;/p&gt; &lt;p&gt;Taking these extra measures won&amp;#39;t make the honeypot less valuable.&lt;/p&gt; &lt;/div&gt;&lt;!-- SC_ON --&gt;</content><id>t1_g6ow7kv</id><link href="https://old.reddit.com/r/docker/comments/izobdi/trapping_hackers_with_containerized_deception/g6ow7kv/"/><updated>2020-09-26T15:22:56+00:00</updated><title>/u/mister2d on Trapping Hackers with Containerized Deception</title></entry><entry><author><name>/u/chamunks</name><uri>https://old.reddit.com/user/chamunks</uri></author><category term="docker" label="r/docker" /><content type="html">&lt;!-- SC_OFF --&gt;&lt;div class=&quot;md&quot;&gt;&lt;p&gt;Indeed however if you could run it on an isolated honeypot machine with its own ids stuff.&lt;/p&gt; &lt;/div&gt;&lt;!-- SC_ON --&gt;</content><id>t1_g6qjw0v</id><link href="https://old.reddit.com/r/docker/comments/izobdi/trapping_hackers_with_containerized_deception/g6qjw0v/"/><updated>2020-09-26T22:25:53+00:00</updated><title>/u/chamunks on Trapping Hackers with Containerized Deception</title></entry><entry><author><name>/u/mister2d</name><uri>https://old.reddit.com/user/mister2d</uri></author><category term="docker" label="r/docker" /><content type="html">&lt;!-- SC_OFF --&gt;&lt;div class=&quot;md&quot;&gt;&lt;p&gt;Yep, my whole point is to minimize the possibility of a container breakout and if that happens to not have root access. If you gain root on any box, then the attacker has promiscuous access to the network stack.&lt;/p&gt; &lt;/div&gt;&lt;!-- SC_ON --&gt;</content><id>t1_g6qxvci</id><link href="https://old.reddit.com/r/docker/comments/izobdi/trapping_hackers_with_containerized_deception/g6qxvci/"/><updated>2020-09-26T23:56:33+00:00</updated><title>/u/mister2d on Trapping Hackers with Containerized Deception</title></entry></feed>